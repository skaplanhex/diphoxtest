	logical dir,oneb,twob,lchoi
*********************************************************
*                                                       *
* this file was generated by huwfun.                    *
*                                                       *
*********************************************************
*
*     ntuple id:      10   
*     ntuple title:   gamma-gamma events
*     creation:       16/10/96 18.34.54
*
*********************************************************
*
	integer iprov
	real weight
	common /fixblo/ iprov,weight
*
	real we,wpx,wpy,wpz
	integer ntrack
	common /varblok2/ ntrack,we(3),wpx(3),wpy(3),wpz(3)
*
	real wx3,wx4
	common/fragblo/wx3,wx4
*
	call histo_init(dir,oneb,twob)
	call hbname(10,' ',0,'$clear')
	call hbname(10,'fixblo',iprov,'$set')
*
	call hbname(10,'varblok2',ntrack,'$set')
      
	if (oneb.or.twob) then
          call hbname(10,'fragblo',wx3,'$set')
        endif
*
*
*--   enter user code here
	lchoi = oneb.or.twob
	iunit = 10
c normalisation
	call hnoent(iunit,ievt) ! donne le nombre d'evenement dans le ntuple
	do i=1,ievt
	  call hcdir('//ntuple',' ')
	  call hgnt(iunit,i,ierr)
	  call coupkine(dir,oneb,twob,xmgg,pt3,pt4,qt,fi34,
     #	  y3,y4,yboost,ystar,ygg,p_out3,p_out4,z3_trig,z4_trig,
     #	  cos_thetas,icoup)
	  call hcdir('//histogramme',' ')			
	  if (icoup.ne.0) then
	    call remplissage(iprov,xmgg,pt3,pt4,qt,fi34,
     #	    y3,y4,yboost,ystar,ygg,p_out3,p_out4,z3_trig,z4_trig,
     #	    cos_thetas,wx3,wx4,weight)
	  endif
	enddo
	call hidopt(0,'perr')
	call histo_close(inbevent,wfirst_int)
*
*
      end
c	
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	
C correction d'un bug le 29/07/99, pt5 n'etait pas definie pour le twob
C correction d'un bug le 12/05/00, mauvaise definition de l'energie depose 
c pour le oneb
	subroutine coupkine(dir,oneb,twob,xmgg,pt3,pt4,qt,fi34,
     #	y3,y4,yboost,ystar,ygg,p_out3,p_out4,z3_trig,z4_trig,
     #	cos_thetas,icoup)
	logical rapidite,pete,isol,masscut
	logical ident
	logical dir,oneb,twob
	COMMON /FIXBLO/ iprov,weight
	COMMON /VARBLOK2/ NTRACK,WE(3),WPX(3),WPY(3),WPZ(3)
	COMMON/FRAGBLO/WX3,WX4
** 	call further_param(pt1min,pt2min,ymax,ymin,etmin,
**      #	r,xmasmax,xmasmin)
** 	call further_param(pt1min,pt2min,ymax,ymin,
**      #	xmasmax,xmasmin)
	call further_param(pt1min,pt2min,y1max,y1min,
     #	y2max,y2min,xmasmax,xmasmin,ident)
c dans cette version on ne permet pas de mettre un critere d'isolement
c ici
	r = 0.4
	etmin = 7000.
	isol = .true.
	xinfty = 1.e+8	
	zero = 0.
	un = 1.	
	if (dir) then
	  wx3 = 1.
	  wx4 = 1.
	endif 
	xmgg2 = 2.*
     #	(we(1)*we(2)-wpx(1)*wpx(2)-wpy(1)*wpy(2)-wpz(1)*wpz(2))
	xmgg = sqrt(xmgg2)
	pt3 = sqrt(wpx(1)**2+wpy(1)**2)
	pt4 = sqrt(wpx(2)**2+wpy(2)**2)
	y3 = log((we(1)+wpz(1))/(we(1)-wpz(1)))*0.5
	y4 = log((we(2)+wpz(2))/(we(2)-wpz(2)))*0.5
	ystar = (y3-y4)/2.
	yboost = (y3+y4)/2.
	cos_thetas = abs(tanh(ystar))
c ygg est la rapidite du systeme photon-photon (pion-pion)
	ygg = log((we(1)+we(2)+wpz(1)+wpz(2))/
     #	(we(1)+we(2)-wpz(1)-wpz(2)))*0.5
	if (ntrack.eq.3) then
	  pt5 = sqrt(wpx(3)**2+wpy(3)**2)
	  xnumy5 = (we(3)+wpz(3))
	  xdeny5 = (we(3)-wpz(3))
	  if (xnumy5.eq.zero.or.xdeny5.eq.zero) then
	    if (wpz(3).le.zero) then
	      y5 = -xinfty
	    else
	      y5 = xinfty
	    endif
	  else if (xnumy5.gt.zero.and.xdeny5.gt.zero) then
	    y5 = log((we(3)+wpz(3))/(we(3)-wpz(3)))*0.5
	  endif
	else if (iprov.eq.22.or.iprov.eq.32) then
	  y5 = y3
	  if (dir) then
	    pt5 = pt4-pt3
	  else if (oneb) then
	    if (wx4.eq.un) then
	      pt5 = pt4-pt3/wx3
	    else if (wx3.eq.un) then
	      pt5 = pt3-pt4/wx4
	    endif
	  else if (twob) then
	    pt5 = pt4/wx4-pt3/wx3
	  endif
	else if (iprov.eq.23.or.iprov.eq.33) then
	  y5 = y4
	  if (dir) then
	    pt5 = pt3-pt4
	  else if (oneb) then
	    if (wx4.eq.un) then
	      pt5 = pt3/wx3-pt4
	    else if (wx3.eq.un) then
	      pt5 = pt4/wx4-pt3
	    endif
	  else if (twob) then
	    pt5 = pt3/wx3-pt4/wx4
	  endif
	else
	  pt5 =0.
	  y5 = 0.
	endif
	cfi34 = (wpx(1)*wpx(2)+wpy(1)*wpy(2))/(pt3*pt4)
	if (ntrack.eq.3) then
	  cfi35 = (wpx(1)*wpx(3)+wpy(1)*wpy(3))/(pt3*pt5)
	  cfi45 = (wpx(3)*wpx(2)+wpy(3)*wpy(2))/(pt5*pt4)
	  fi35 = wacos(cfi35)
	  fi45 = wacos(cfi45)
	endif
	pi = atan(1.)*4.
	if (abs(cfi34).gt.1.0001) then
	  write (6,*) 'alerte',cfi34
	else if (abs(cfi34).gt.un) then
	  cfi34 = sign(un,cfi34)
	else
	  cfi34 = cfi34
	endif
	fi34 = wacos( cfi34 )
	qt = sqrt( (wpx(1)+wpx(2))**2+(wpy(1)+wpy(2))**2 )
	p_out3 = (wpx(1)*wpy(2)-wpx(2)*wpy(1))/pt3
	p_out4 = (wpx(2)*wpy(1)-wpx(1)*wpy(2))/pt4
	z3_trig = -pt4/pt3*cfi34
	z4_trig = -pt3/pt4*cfi34
c
	if (ntrack.eq.3) then
	  dist35 = sqrt((y3-y5)**2+(fi35)**2)
	  dist45 = sqrt((y4-y5)**2+(fi45)**2)
	  if ((dist35.gt.r)
     #	  .and.(dist45.gt.r)) then
	    edep3 = (1.-wx3)/wx3*pt3
	    edep4 = (1.-wx4)/wx4*pt4
** 	    isol = (edep3.le.etmin).and.(edep4.le.etmin)
	  else if ((dist35.le.r)
     #	  .and.(dist45.gt.r)) then
	    edep3 = pt5 + (1.-wx3)/wx3*pt3
	    edep4 = (1.-wx4)/wx4*pt4
** 	    isol = (edep3.le.etmin).and.(edep4.le.etmin)
	  else if ((dist35.gt.r)
     #	  .and.(dist45.le.r)) then
	    edep3 = (1.-wx3)/wx3*pt3
	    edep4 = pt5 + (1.-wx4)/wx4*pt4
** 	    isol = (edep3.le.etmin).and.(edep4.le.etmin)
	  endif
	else if (iprov.eq.22.or.iprov.eq.32) then
	  if (dir) then
	    edep3 = pt5 
	    edep4 = 0.
	  else if (oneb) then
	    if (wx4.eq.un) then
	      edep3 = pt5 + (1.-wx3)/wx3*pt3
	      edep4 = 0.
	    else if (wx3.eq.un) then
	      edep4 = pt5 + (1.-wx4)/wx4*pt4
	      edep3 = 0.
	    endif
	  else if (twob) then
	    edep3 = pt5 + (1.-wx3)/wx3*pt3
	    edep4 = (1.-wx4)/wx4*pt4
	  endif
** 	  isol = (edep3.le.etmin).and.(edep4.le.etmin)
	else if (iprov.eq.23.or.iprov.eq.33) then
	  if (dir) then
	    edep4 = pt5 
	    edep3 = 0.
	  else if (oneb) then
	    if (wx4.eq.un) then
	      edep4 = pt5
	      edep3 = (1.-wx3)/wx3*pt3
	    else if (wx3.eq.un) then
	      edep3 = pt5
	      edep4 = (1.-wx4)/wx4*pt4
	    endif
	  else if (twob) then
	    edep4 = pt5 + (1.-wx4)/wx4*pt4
	    edep3 = (1.-wx3)/wx3*pt3
	  endif
** 	    isol = (edep3.le.etmin).and.(edep4.le.etmin)
	else
	  dist35 = 0.
	  dist45 = 0.
	  edep3 = (1.-wx3)/wx3*pt3
	  edep4 = (1.-wx4)/wx4*pt4
** 	  isol = (edep3.le.etmin).and.(edep4.le.etmin)
	endif
	x4min = pt4/(pt4+etmin)
	x3min = pt3/(pt3+etmin)	
	if (ident) then	
	  if (pt3.ge.pt4) then
	    pt1 = pt3
	    pt2 = pt4
	    y1 = y3
	    y2 = y4
	  else
	    pt1 = pt4
	    pt2 = pt3
	    y1 = y4
	    y2 = y3
	  endif
	else
	  pt1 = pt3
	  pt2 = pt4
	  y1 = y3
	  y2 = y4
	endif
	edep = max(edep3,edep4)
c
	masscut = (xmgg.le.xmasmax.and.xmgg.ge.xmasmin)
c
	rapidite = (y3.le.y1max.and.y3.ge.y1min).and.
     #	(y4.le.y2max.and.y4.ge.y2min)
	pete = pt1.ge.pt1min.and.pt2.ge.pt2min
c
	if (rapidite.and.pete.and.isol) then
	  icoup = 1
	else
	  icoup = 0
	endif
	end
c********************************************************************
	real function wacos(x)
	un = 1.
	unp = 1. + 1.e-4
	zero = 0.
	pi=atan(1.)*4.
	if (abs(x).le.un) then
	  wacos = acos(x)
	else if (abs(x).gt.un.and.abs(x).lt.unp) then
	  if (x.lt.zero) then
	    wacos = pi
	  else
	    wacos = 0.
	  endif
	else
	  write (*,*) 'alerte dans wacos argument > 1:',x
	  wacos = 0.
	endif
	return
	end
